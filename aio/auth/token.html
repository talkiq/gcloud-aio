<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>gcloud.aio.auth.token API documentation</title>
<meta name="description" content="Google Cloud auth via service account file" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcloud.aio.auth.token</code></h1>
</header>
<section id="section-intro">
<p>Google Cloud auth via service account file</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Google Cloud auth via service account file
&#34;&#34;&#34;
import datetime
import enum
import io
import json
import os
import time
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from typing import Union
from urllib.parse import urlencode

import backoff
import cryptography  # pylint: disable=unused-import
import jwt

from .build_constants import BUILD_GCLOUD_REST
from .session import AioSession
# N.B. the cryptography library is required when calling jwt.encrypt() with
# algorithm=&#39;RS256&#39;. It does not need to be imported here, but this allows us
# to throw this error at load time rather than lazily during normal operations,
# where plumbing this error through will require several changes to otherwise-
# good error handling.

# Handle differences in exceptions
try:
    CustomFileError = FileNotFoundError
except NameError:
    CustomFileError = IOError


# Selectively load libraries based on the package
if BUILD_GCLOUD_REST:
    from requests import Session
else:
    from aiohttp import ClientSession as Session
    import asyncio

GCE_METADATA_BASE = &#39;http://metadata.google.internal/computeMetadata/v1&#39;
GCE_METADATA_HEADERS = {&#39;metadata-flavor&#39;: &#39;Google&#39;}
GCE_ENDPOINT_PROJECT = (f&#39;{GCE_METADATA_BASE}/project/project-id&#39;)
GCE_ENDPOINT_TOKEN = (f&#39;{GCE_METADATA_BASE}/instance/service-accounts&#39;
                      &#39;/default/token?recursive=true&#39;)
GCLOUD_TOKEN_DURATION = 3600
REFRESH_HEADERS = {&#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;}


class Type(enum.Enum):
    AUTHORIZED_USER = &#39;authorized_user&#39;
    GCE_METADATA = &#39;gce_metadata&#39;
    SERVICE_ACCOUNT = &#39;service_account&#39;


def get_service_data(
        service: Optional[Union[str, io.IOBase]]) -&gt; Dict[str, Any]:
    service = service or os.environ.get(&#39;GOOGLE_APPLICATION_CREDENTIALS&#39;)
    if not service:
        cloudsdk_config = os.environ.get(&#39;CLOUDSDK_CONFIG&#39;)
        sdkpath = (cloudsdk_config
                   or os.path.join(os.path.expanduser(&#39;~&#39;), &#39;.config&#39;,
                                   &#39;gcloud&#39;))
        service = os.path.join(sdkpath, &#39;application_default_credentials.json&#39;)
        set_explicitly = bool(cloudsdk_config)
    else:
        set_explicitly = True

    try:
        try:
            with open(service, &#39;r&#39;) as f:
                data: Dict[str, Any] = json.loads(f.read())
                return data
        except TypeError:
            data: Dict[str, Any] = json.loads(service.read())
            return data
    except CustomFileError:
        if set_explicitly:
            # only warn users if they have explicitly set the service_file path
            raise

        return {}
    except Exception:  # pylint: disable=broad-except
        return {}


class Token:
    # pylint: disable=too-many-instance-attributes
    def __init__(self, service_file: Optional[Union[str, io.IOBase]] = None,
                 session: Optional[Session] = None,
                 scopes: List[str] = None) -&gt; None:
        self.service_data = get_service_data(service_file)
        if self.service_data:
            self.token_type = Type(self.service_data[&#39;type&#39;])
            self.token_uri = self.service_data.get(
                &#39;token_uri&#39;, &#39;https://oauth2.googleapis.com/token&#39;)
        else:
            # At this point, all we can do is assume we&#39;re running somewhere
            # with default credentials, eg. GCE.
            self.token_type = Type.GCE_METADATA
            self.token_uri = GCE_ENDPOINT_TOKEN

        self.session = AioSession(session)
        self.scopes = &#39; &#39;.join(scopes or [])
        if self.token_type == Type.SERVICE_ACCOUNT and not self.scopes:
            raise Exception(&#39;scopes must be provided when token type is &#39;
                            &#39;service account&#39;)

        self.access_token: Optional[str] = None
        self.access_token_duration = 0
        self.access_token_acquired_at = datetime.datetime(1970, 1, 1)

        self.acquiring: Optional[asyncio.Future] = None

    async def get_project(self) -&gt; Optional[str]:
        project = (os.environ.get(&#39;GOOGLE_CLOUD_PROJECT&#39;)
                   or os.environ.get(&#39;GCLOUD_PROJECT&#39;)
                   or os.environ.get(&#39;APPLICATION_ID&#39;))

        if self.token_type == Type.GCE_METADATA:
            await self.ensure_token()
            resp = await self.session.get(GCE_ENDPOINT_PROJECT, timeout=10,
                                          headers=GCE_METADATA_HEADERS)

            if not project:
                try:
                    project = await resp.text()
                except (AttributeError, TypeError):
                    project = str(resp.text)

        elif self.token_type == Type.SERVICE_ACCOUNT:
            project = project or self.service_data.get(&#39;project_id&#39;)

        return project

    async def get(self) -&gt; Optional[str]:
        await self.ensure_token()
        return self.access_token

    async def ensure_token(self) -&gt; None:
        if self.acquiring:
            await self.acquiring
            return

        if not self.access_token:
            self.acquiring = asyncio.ensure_future(self.acquire_access_token())
            await self.acquiring
            return

        now = datetime.datetime.utcnow()
        delta = (now - self.access_token_acquired_at).total_seconds()
        if delta &lt;= self.access_token_duration / 2:
            return

        self.acquiring = asyncio.ensure_future(self.acquire_access_token())
        await self.acquiring

    async def _refresh_authorized_user(self,
                                       timeout: int) -&gt; Dict[str, str]:
        payload = urlencode({
            &#39;grant_type&#39;: &#39;refresh_token&#39;,
            &#39;client_id&#39;: self.service_data[&#39;client_id&#39;],
            &#39;client_secret&#39;: self.service_data[&#39;client_secret&#39;],
            &#39;refresh_token&#39;: self.service_data[&#39;refresh_token&#39;],
        })

        return await self.session.post(url=self.token_uri, data=payload,
                                       headers=REFRESH_HEADERS,
                                       timeout=timeout)

    async def _refresh_gce_metadata(self,
                                    timeout: int) -&gt; Dict[str, str]:
        return await self.session.get(url=self.token_uri,
                                      headers=GCE_METADATA_HEADERS,
                                      timeout=timeout)

    async def _refresh_service_account(self,
                                       timeout: int) -&gt; Dict[str, str]:
        now = int(time.time())
        assertion_payload = {
            &#39;aud&#39;: self.token_uri,
            &#39;exp&#39;: now + GCLOUD_TOKEN_DURATION,
            &#39;iat&#39;: now,
            &#39;iss&#39;: self.service_data[&#39;client_email&#39;],
            &#39;scope&#39;: self.scopes,
        }

        # N.B. algorithm=&#39;RS256&#39; requires an extra 240MB in dependencies...
        assertion = jwt.encode(assertion_payload,
                               self.service_data[&#39;private_key&#39;],
                               algorithm=&#39;RS256&#39;)
        payload = urlencode({
            &#39;assertion&#39;: assertion,
            &#39;grant_type&#39;: &#39;urn:ietf:params:oauth:grant-type:jwt-bearer&#39;,
        })

        return await self.session.post(self.token_uri, data=payload,
                                       headers=REFRESH_HEADERS,
                                       timeout=timeout)

    @backoff.on_exception(backoff.expo, Exception, max_tries=5)  # type: ignore
    async def acquire_access_token(self, timeout: int = 10) -&gt; None:
        if self.token_type == Type.AUTHORIZED_USER:
            resp = await self._refresh_authorized_user(timeout=timeout)
        elif self.token_type == Type.GCE_METADATA:
            resp = await self._refresh_gce_metadata(timeout=timeout)
        elif self.token_type == Type.SERVICE_ACCOUNT:
            resp = await self._refresh_service_account(timeout=timeout)
        else:
            raise Exception(f&#39;unsupported token type {self.token_type}&#39;)

        content = await resp.json()

        self.access_token = str(content[&#39;access_token&#39;])
        self.access_token_duration = int(content[&#39;expires_in&#39;])
        self.access_token_acquired_at = datetime.datetime.utcnow()
        self.acquiring = None

    async def close(self):
        await self.session.close()

    async def __aenter__(self) -&gt; &#39;Token&#39;:
        return self

    async def __aexit__(self, *args) -&gt; None:
        await self.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gcloud.aio.auth.token.get_service_data"><code class="name flex">
<span>def <span class="ident">get_service_data</span></span>(<span>service: Union[str, io.IOBase, NoneType]) -> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_service_data(
        service: Optional[Union[str, io.IOBase]]) -&gt; Dict[str, Any]:
    service = service or os.environ.get(&#39;GOOGLE_APPLICATION_CREDENTIALS&#39;)
    if not service:
        cloudsdk_config = os.environ.get(&#39;CLOUDSDK_CONFIG&#39;)
        sdkpath = (cloudsdk_config
                   or os.path.join(os.path.expanduser(&#39;~&#39;), &#39;.config&#39;,
                                   &#39;gcloud&#39;))
        service = os.path.join(sdkpath, &#39;application_default_credentials.json&#39;)
        set_explicitly = bool(cloudsdk_config)
    else:
        set_explicitly = True

    try:
        try:
            with open(service, &#39;r&#39;) as f:
                data: Dict[str, Any] = json.loads(f.read())
                return data
        except TypeError:
            data: Dict[str, Any] = json.loads(service.read())
            return data
    except CustomFileError:
        if set_explicitly:
            # only warn users if they have explicitly set the service_file path
            raise

        return {}
    except Exception:  # pylint: disable=broad-except
        return {}</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcloud.aio.auth.token.Token"><code class="flex name class">
<span>class <span class="ident">Token</span></span>
<span>(</span><span>service_file: Union[str, io.IOBase, NoneType] = None, session: Union[aiohttp.client.ClientSession, NoneType] = None, scopes: List[str] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Token:
    # pylint: disable=too-many-instance-attributes
    def __init__(self, service_file: Optional[Union[str, io.IOBase]] = None,
                 session: Optional[Session] = None,
                 scopes: List[str] = None) -&gt; None:
        self.service_data = get_service_data(service_file)
        if self.service_data:
            self.token_type = Type(self.service_data[&#39;type&#39;])
            self.token_uri = self.service_data.get(
                &#39;token_uri&#39;, &#39;https://oauth2.googleapis.com/token&#39;)
        else:
            # At this point, all we can do is assume we&#39;re running somewhere
            # with default credentials, eg. GCE.
            self.token_type = Type.GCE_METADATA
            self.token_uri = GCE_ENDPOINT_TOKEN

        self.session = AioSession(session)
        self.scopes = &#39; &#39;.join(scopes or [])
        if self.token_type == Type.SERVICE_ACCOUNT and not self.scopes:
            raise Exception(&#39;scopes must be provided when token type is &#39;
                            &#39;service account&#39;)

        self.access_token: Optional[str] = None
        self.access_token_duration = 0
        self.access_token_acquired_at = datetime.datetime(1970, 1, 1)

        self.acquiring: Optional[asyncio.Future] = None

    async def get_project(self) -&gt; Optional[str]:
        project = (os.environ.get(&#39;GOOGLE_CLOUD_PROJECT&#39;)
                   or os.environ.get(&#39;GCLOUD_PROJECT&#39;)
                   or os.environ.get(&#39;APPLICATION_ID&#39;))

        if self.token_type == Type.GCE_METADATA:
            await self.ensure_token()
            resp = await self.session.get(GCE_ENDPOINT_PROJECT, timeout=10,
                                          headers=GCE_METADATA_HEADERS)

            if not project:
                try:
                    project = await resp.text()
                except (AttributeError, TypeError):
                    project = str(resp.text)

        elif self.token_type == Type.SERVICE_ACCOUNT:
            project = project or self.service_data.get(&#39;project_id&#39;)

        return project

    async def get(self) -&gt; Optional[str]:
        await self.ensure_token()
        return self.access_token

    async def ensure_token(self) -&gt; None:
        if self.acquiring:
            await self.acquiring
            return

        if not self.access_token:
            self.acquiring = asyncio.ensure_future(self.acquire_access_token())
            await self.acquiring
            return

        now = datetime.datetime.utcnow()
        delta = (now - self.access_token_acquired_at).total_seconds()
        if delta &lt;= self.access_token_duration / 2:
            return

        self.acquiring = asyncio.ensure_future(self.acquire_access_token())
        await self.acquiring

    async def _refresh_authorized_user(self,
                                       timeout: int) -&gt; Dict[str, str]:
        payload = urlencode({
            &#39;grant_type&#39;: &#39;refresh_token&#39;,
            &#39;client_id&#39;: self.service_data[&#39;client_id&#39;],
            &#39;client_secret&#39;: self.service_data[&#39;client_secret&#39;],
            &#39;refresh_token&#39;: self.service_data[&#39;refresh_token&#39;],
        })

        return await self.session.post(url=self.token_uri, data=payload,
                                       headers=REFRESH_HEADERS,
                                       timeout=timeout)

    async def _refresh_gce_metadata(self,
                                    timeout: int) -&gt; Dict[str, str]:
        return await self.session.get(url=self.token_uri,
                                      headers=GCE_METADATA_HEADERS,
                                      timeout=timeout)

    async def _refresh_service_account(self,
                                       timeout: int) -&gt; Dict[str, str]:
        now = int(time.time())
        assertion_payload = {
            &#39;aud&#39;: self.token_uri,
            &#39;exp&#39;: now + GCLOUD_TOKEN_DURATION,
            &#39;iat&#39;: now,
            &#39;iss&#39;: self.service_data[&#39;client_email&#39;],
            &#39;scope&#39;: self.scopes,
        }

        # N.B. algorithm=&#39;RS256&#39; requires an extra 240MB in dependencies...
        assertion = jwt.encode(assertion_payload,
                               self.service_data[&#39;private_key&#39;],
                               algorithm=&#39;RS256&#39;)
        payload = urlencode({
            &#39;assertion&#39;: assertion,
            &#39;grant_type&#39;: &#39;urn:ietf:params:oauth:grant-type:jwt-bearer&#39;,
        })

        return await self.session.post(self.token_uri, data=payload,
                                       headers=REFRESH_HEADERS,
                                       timeout=timeout)

    @backoff.on_exception(backoff.expo, Exception, max_tries=5)  # type: ignore
    async def acquire_access_token(self, timeout: int = 10) -&gt; None:
        if self.token_type == Type.AUTHORIZED_USER:
            resp = await self._refresh_authorized_user(timeout=timeout)
        elif self.token_type == Type.GCE_METADATA:
            resp = await self._refresh_gce_metadata(timeout=timeout)
        elif self.token_type == Type.SERVICE_ACCOUNT:
            resp = await self._refresh_service_account(timeout=timeout)
        else:
            raise Exception(f&#39;unsupported token type {self.token_type}&#39;)

        content = await resp.json()

        self.access_token = str(content[&#39;access_token&#39;])
        self.access_token_duration = int(content[&#39;expires_in&#39;])
        self.access_token_acquired_at = datetime.datetime.utcnow()
        self.acquiring = None

    async def close(self):
        await self.session.close()

    async def __aenter__(self) -&gt; &#39;Token&#39;:
        return self

    async def __aexit__(self, *args) -&gt; None:
        await self.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gcloud.aio.auth.token.Token.acquire_access_token"><code class="name flex">
<span>async def <span class="ident">acquire_access_token</span></span>(<span>self, timeout: int = 10) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@backoff.on_exception(backoff.expo, Exception, max_tries=5)  # type: ignore
async def acquire_access_token(self, timeout: int = 10) -&gt; None:
    if self.token_type == Type.AUTHORIZED_USER:
        resp = await self._refresh_authorized_user(timeout=timeout)
    elif self.token_type == Type.GCE_METADATA:
        resp = await self._refresh_gce_metadata(timeout=timeout)
    elif self.token_type == Type.SERVICE_ACCOUNT:
        resp = await self._refresh_service_account(timeout=timeout)
    else:
        raise Exception(f&#39;unsupported token type {self.token_type}&#39;)

    content = await resp.json()

    self.access_token = str(content[&#39;access_token&#39;])
    self.access_token_duration = int(content[&#39;expires_in&#39;])
    self.access_token_acquired_at = datetime.datetime.utcnow()
    self.acquiring = None</code></pre>
</details>
</dd>
<dt id="gcloud.aio.auth.token.Token.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self):
    await self.session.close()</code></pre>
</details>
</dd>
<dt id="gcloud.aio.auth.token.Token.ensure_token"><code class="name flex">
<span>async def <span class="ident">ensure_token</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def ensure_token(self) -&gt; None:
    if self.acquiring:
        await self.acquiring
        return

    if not self.access_token:
        self.acquiring = asyncio.ensure_future(self.acquire_access_token())
        await self.acquiring
        return

    now = datetime.datetime.utcnow()
    delta = (now - self.access_token_acquired_at).total_seconds()
    if delta &lt;= self.access_token_duration / 2:
        return

    self.acquiring = asyncio.ensure_future(self.acquire_access_token())
    await self.acquiring</code></pre>
</details>
</dd>
<dt id="gcloud.aio.auth.token.Token.get"><code class="name flex">
<span>async def <span class="ident">get</span></span>(<span>self) -> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get(self) -&gt; Optional[str]:
    await self.ensure_token()
    return self.access_token</code></pre>
</details>
</dd>
<dt id="gcloud.aio.auth.token.Token.get_project"><code class="name flex">
<span>async def <span class="ident">get_project</span></span>(<span>self) -> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_project(self) -&gt; Optional[str]:
    project = (os.environ.get(&#39;GOOGLE_CLOUD_PROJECT&#39;)
               or os.environ.get(&#39;GCLOUD_PROJECT&#39;)
               or os.environ.get(&#39;APPLICATION_ID&#39;))

    if self.token_type == Type.GCE_METADATA:
        await self.ensure_token()
        resp = await self.session.get(GCE_ENDPOINT_PROJECT, timeout=10,
                                      headers=GCE_METADATA_HEADERS)

        if not project:
            try:
                project = await resp.text()
            except (AttributeError, TypeError):
                project = str(resp.text)

    elif self.token_type == Type.SERVICE_ACCOUNT:
        project = project or self.service_data.get(&#39;project_id&#39;)

    return project</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gcloud.aio.auth.token.Type"><code class="flex name class">
<span>class <span class="ident">Type</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Type(enum.Enum):
    AUTHORIZED_USER = &#39;authorized_user&#39;
    GCE_METADATA = &#39;gce_metadata&#39;
    SERVICE_ACCOUNT = &#39;service_account&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gcloud.aio.auth.token.Type.AUTHORIZED_USER"><code class="name">var <span class="ident">AUTHORIZED_USER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gcloud.aio.auth.token.Type.GCE_METADATA"><code class="name">var <span class="ident">GCE_METADATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gcloud.aio.auth.token.Type.SERVICE_ACCOUNT"><code class="name">var <span class="ident">SERVICE_ACCOUNT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcloud.aio.auth" href="index.html">gcloud.aio.auth</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gcloud.aio.auth.token.get_service_data" href="#gcloud.aio.auth.token.get_service_data">get_service_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcloud.aio.auth.token.Token" href="#gcloud.aio.auth.token.Token">Token</a></code></h4>
<ul class="">
<li><code><a title="gcloud.aio.auth.token.Token.acquire_access_token" href="#gcloud.aio.auth.token.Token.acquire_access_token">acquire_access_token</a></code></li>
<li><code><a title="gcloud.aio.auth.token.Token.close" href="#gcloud.aio.auth.token.Token.close">close</a></code></li>
<li><code><a title="gcloud.aio.auth.token.Token.ensure_token" href="#gcloud.aio.auth.token.Token.ensure_token">ensure_token</a></code></li>
<li><code><a title="gcloud.aio.auth.token.Token.get" href="#gcloud.aio.auth.token.Token.get">get</a></code></li>
<li><code><a title="gcloud.aio.auth.token.Token.get_project" href="#gcloud.aio.auth.token.Token.get_project">get_project</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gcloud.aio.auth.token.Type" href="#gcloud.aio.auth.token.Type">Type</a></code></h4>
<ul class="">
<li><code><a title="gcloud.aio.auth.token.Type.AUTHORIZED_USER" href="#gcloud.aio.auth.token.Type.AUTHORIZED_USER">AUTHORIZED_USER</a></code></li>
<li><code><a title="gcloud.aio.auth.token.Type.GCE_METADATA" href="#gcloud.aio.auth.token.Type.GCE_METADATA">GCE_METADATA</a></code></li>
<li><code><a title="gcloud.aio.auth.token.Type.SERVICE_ACCOUNT" href="#gcloud.aio.auth.token.Type.SERVICE_ACCOUNT">SERVICE_ACCOUNT</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>