<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>gcloud.aio.datastore.datastore API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcloud.aio.datastore.datastore</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import io
import json
import logging
import os
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from typing import Union

from gcloud.aio.auth import AioSession  # pylint: disable=no-name-in-module
from gcloud.aio.auth import BUILD_GCLOUD_REST  # pylint: disable=no-name-in-module
from gcloud.aio.auth import Token  # pylint: disable=no-name-in-module
from gcloud.aio.datastore.constants import Consistency
from gcloud.aio.datastore.constants import Mode
from gcloud.aio.datastore.constants import Operation
from gcloud.aio.datastore.datastore_operation import DatastoreOperation
from gcloud.aio.datastore.entity import EntityResult
from gcloud.aio.datastore.key import Key
from gcloud.aio.datastore.query import BaseQuery
from gcloud.aio.datastore.query import QueryResultBatch
from gcloud.aio.datastore.value import Value

# Selectively load libraries based on the package
if BUILD_GCLOUD_REST:
    from requests import Session
else:
    from aiohttp import ClientSession as Session


try:
    API_ROOT = f&#39;http://{os.environ[&#34;DATASTORE_EMULATOR_HOST&#34;]}/v1&#39;
    IS_DEV = True
except KeyError:
    API_ROOT = &#39;https://datastore.googleapis.com/v1&#39;
    IS_DEV = False

SCOPES = [
    &#39;https://www.googleapis.com/auth/cloud-platform&#39;,
    &#39;https://www.googleapis.com/auth/datastore&#39;,
]

log = logging.getLogger(__name__)


class Datastore:
    datastore_operation_kind = DatastoreOperation
    entity_result_kind = EntityResult
    key_kind = Key
    query_result_batch_kind = QueryResultBatch
    value_kind = Value

    def __init__(self, project: Optional[str] = None,
                 service_file: Optional[Union[str, io.IOBase]] = None,
                 namespace: str = &#39;&#39;, session: Optional[Session] = None,
                 token: Optional[Token] = None) -&gt; None:
        self.namespace = namespace
        self.session = AioSession(session)

        if IS_DEV:
            self._project = os.environ.get(&#39;DATASTORE_PROJECT_ID&#39;, &#39;dev&#39;)
            # Tokens are not needed when using dev emulator
            self.token = None
        else:
            self._project = project
            self.token = token or Token(service_file=service_file,
                                        session=self.session.session,
                                        scopes=SCOPES)

    async def project(self) -&gt; str:
        if self._project:
            return self._project

        self._project = await self.token.get_project()
        if self._project:
            return self._project

        raise Exception(&#39;could not determine project, please set it manually&#39;)

    @staticmethod
    def _make_commit_body(mutations: List[Dict[str, Any]],
                          transaction: Optional[str] = None,
                          mode: Mode = Mode.TRANSACTIONAL) -&gt; Dict[str, Any]:
        if not mutations:
            raise Exception(&#39;at least one mutation record is required&#39;)

        if transaction is None and mode != Mode.NON_TRANSACTIONAL:
            raise Exception(&#39;a transaction ID must be provided when mode is &#39;
                            &#39;transactional&#39;)

        data = {
            &#39;mode&#39;: mode.value,
            &#39;mutations&#39;: mutations,
        }
        if transaction is not None:
            data[&#39;transaction&#39;] = transaction
        return data

    async def headers(self) -&gt; Dict[str, str]:
        if IS_DEV:
            return {}

        token = await self.token.get()
        return {
            &#39;Authorization&#39;: f&#39;Bearer {token}&#39;,
        }

    # TODO: support mutations w version specifiers, return new version (commit)
    @classmethod
    def make_mutation(cls, operation: Operation, key: Key,
                      properties: Dict[str, Any] = None) -&gt; Dict[str, Any]:
        if operation == Operation.DELETE:
            return {operation.value: key.to_repr()}

        return {
            operation.value: {
                &#39;key&#39;: key.to_repr(),
                &#39;properties&#39;: {k: cls.value_kind(v).to_repr()
                               for k, v in properties.items()},
            }
        }

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/allocateIds
    async def allocateIds(self, keys: List[Key],
                          session: Optional[Session] = None,
                          timeout: int = 10) -&gt; List[Key]:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:allocateIds&#39;

        payload = json.dumps({
            &#39;keys&#39;: [k.to_repr() for k in keys],
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.post(url, data=payload, headers=headers, timeout=timeout)
        data = await resp.json()

        return [self.key_kind.from_repr(k) for k in data[&#39;keys&#39;]]

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/beginTransaction
    # TODO: support readwrite vs readonly transaction types
    async def beginTransaction(self, session: Optional[Session] = None,
                               timeout: int = 10) -&gt; str:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:beginTransaction&#39;
        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: &#39;0&#39;,
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.post(url, headers=headers, timeout=timeout)
        data = await resp.json()

        transaction: str = data[&#39;transaction&#39;]
        return transaction

    # TODO: return mutation results
    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/commit
    async def commit(self, mutations: List[Dict[str, Any]],
                     transaction: Optional[str] = None,
                     mode: Mode = Mode.TRANSACTIONAL,
                     session: Optional[Session] = None,
                     timeout: int = 10) -&gt; None:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:commit&#39;

        body = self._make_commit_body(mutations, transaction=transaction,
                                      mode=mode)
        payload = json.dumps(body).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        await s.post(url, data=payload, headers=headers, timeout=timeout)

    # https://cloud.google.com/datastore/docs/reference/admin/rest/v1/projects/export
    async def export(self, output_bucket_prefix: str,
                     kinds: Optional[List[str]] = None,
                     namespaces: Optional[List[str]] = None,
                     labels: Optional[Dict[str, str]] = None,
                     session: Optional[Session] = None,
                     timeout: int = 10) -&gt; DatastoreOperation:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:export&#39;

        payload = json.dumps({
            &#39;entityFilter&#39;: {
                &#39;kinds&#39;: kinds or [],
                &#39;namespaceIds&#39;: namespaces or [],
            },
            &#39;labels&#39;: labels or {},
            &#39;outputUrlPrefix&#39;: f&#39;gs://{output_bucket_prefix}&#39;,
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.post(url, data=payload, headers=headers,
                            timeout=timeout)
        data: dict = await resp.json()

        return self.datastore_operation_kind.from_repr(data)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects.operations/get
    async def get_datastore_operation(self, name: str,
                                      session: Optional[Session] = None,
                                      timeout: int = 10) -&gt; DatastoreOperation:
        url = f&#39;{API_ROOT}/{name}&#39;

        headers = await self.headers()
        headers.update({
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.get(url, headers=headers, timeout=timeout)
        data: dict = await resp.json()

        return self.datastore_operation_kind.from_repr(data)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/lookup
    async def lookup(self, keys: List[Key], transaction: str = None,
                     consistency: Consistency = Consistency.STRONG,
                     session: Optional[Session] = None,
                     timeout: int = 10) -&gt; Dict[str, Union[EntityResult, Key]]:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:lookup&#39;

        if transaction:
            options = {&#39;transaction&#39;: transaction}
        else:
            options = {&#39;readConsistency&#39;: consistency.value}
        payload = json.dumps({
            &#39;keys&#39;: [k.to_repr() for k in keys],
            &#39;readOptions&#39;: options,
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.post(url, data=payload, headers=headers, timeout=timeout)

        data: dict = await resp.json()

        return {
            &#39;found&#39;: [self.entity_result_kind.from_repr(e)
                      for e in data.get(&#39;found&#39;, [])],
            &#39;missing&#39;: [self.entity_result_kind.from_repr(e)
                        for e in data.get(&#39;missing&#39;, [])],
            &#39;deferred&#39;: [self.key_kind.from_repr(k)
                         for k in data.get(&#39;deferred&#39;, [])],
        }

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/reserveIds
    async def reserveIds(self, keys: List[Key], database_id: str = &#39;&#39;,
                         session: Optional[Session] = None,
                         timeout: int = 10) -&gt; None:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:reserveIds&#39;

        payload = json.dumps({
            &#39;databaseId&#39;: database_id,
            &#39;keys&#39;: [k.to_repr() for k in keys],
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        await s.post(url, data=payload, headers=headers, timeout=timeout)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/rollback
    async def rollback(self, transaction: str,
                       session: Optional[Session] = None,
                       timeout: int = 10) -&gt; None:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:rollback&#39;

        payload = json.dumps({
            &#39;transaction&#39;: transaction,
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        await s.post(url, data=payload, headers=headers, timeout=timeout)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/runQuery
    async def runQuery(self, query: BaseQuery, transaction: str = None,
                       consistency: Consistency = Consistency.EVENTUAL,
                       session: Optional[Session] = None,
                       timeout: int = 10) -&gt; QueryResultBatch:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:runQuery&#39;

        if transaction:
            options = {&#39;transaction&#39;: transaction}
        else:
            options = {&#39;readConsistency&#39;: consistency.value}
        payload = json.dumps({
            &#39;partitionId&#39;: {
                &#39;projectId&#39;: project,
                &#39;namespaceId&#39;: self.namespace,
            },
            query.json_key:  query.to_repr(),
            &#39;readOptions&#39;: options,
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.post(url, data=payload, headers=headers, timeout=timeout)

        data: dict = await resp.json()
        return self.query_result_batch_kind.from_repr(data[&#39;batch&#39;])

    async def delete(self, key: Key,
                     session: Optional[Session] = None) -&gt; None:
        return await self.operate(Operation.DELETE, key, session=session)

    async def insert(self, key: Key, properties: Dict[str, Any],
                     session: Optional[Session] = None) -&gt; None:
        return await self.operate(Operation.INSERT, key, properties,
                                  session=session)

    async def update(self, key: Key, properties: Dict[str, Any],
                     session: Optional[Session] = None) -&gt; None:
        return await self.operate(Operation.UPDATE, key, properties,
                                  session=session)

    async def upsert(self, key: Key, properties: Dict[str, Any],
                     session: Optional[Session] = None) -&gt; None:
        return await self.operate(Operation.UPSERT, key, properties,
                                  session=session)

    # TODO: accept Entity rather than key/properties?
    async def operate(self, operation: Operation, key: Key,
                      properties: Dict[str, Any] = None,
                      session: Optional[Session] = None) -&gt; None:
        transaction = await self.beginTransaction(session=session)
        mutation = self.make_mutation(operation, key, properties=properties)
        await self.commit([mutation], transaction=transaction, session=session)

    async def close(self):
        await self.session.close()

    async def __aenter__(self) -&gt; &#39;Datastore&#39;:
        return self

    async def __aexit__(self, *args) -&gt; None:
        await self.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcloud.aio.datastore.datastore.Datastore"><code class="flex name class">
<span>class <span class="ident">Datastore</span></span>
<span>(</span><span>project: Union[str, NoneType] = None, service_file: Union[str, io.IOBase, NoneType] = None, namespace: str = '', session: Union[aiohttp.client.ClientSession, NoneType] = None, token: Union[gcloud.aio.auth.token.Token, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Datastore:
    datastore_operation_kind = DatastoreOperation
    entity_result_kind = EntityResult
    key_kind = Key
    query_result_batch_kind = QueryResultBatch
    value_kind = Value

    def __init__(self, project: Optional[str] = None,
                 service_file: Optional[Union[str, io.IOBase]] = None,
                 namespace: str = &#39;&#39;, session: Optional[Session] = None,
                 token: Optional[Token] = None) -&gt; None:
        self.namespace = namespace
        self.session = AioSession(session)

        if IS_DEV:
            self._project = os.environ.get(&#39;DATASTORE_PROJECT_ID&#39;, &#39;dev&#39;)
            # Tokens are not needed when using dev emulator
            self.token = None
        else:
            self._project = project
            self.token = token or Token(service_file=service_file,
                                        session=self.session.session,
                                        scopes=SCOPES)

    async def project(self) -&gt; str:
        if self._project:
            return self._project

        self._project = await self.token.get_project()
        if self._project:
            return self._project

        raise Exception(&#39;could not determine project, please set it manually&#39;)

    @staticmethod
    def _make_commit_body(mutations: List[Dict[str, Any]],
                          transaction: Optional[str] = None,
                          mode: Mode = Mode.TRANSACTIONAL) -&gt; Dict[str, Any]:
        if not mutations:
            raise Exception(&#39;at least one mutation record is required&#39;)

        if transaction is None and mode != Mode.NON_TRANSACTIONAL:
            raise Exception(&#39;a transaction ID must be provided when mode is &#39;
                            &#39;transactional&#39;)

        data = {
            &#39;mode&#39;: mode.value,
            &#39;mutations&#39;: mutations,
        }
        if transaction is not None:
            data[&#39;transaction&#39;] = transaction
        return data

    async def headers(self) -&gt; Dict[str, str]:
        if IS_DEV:
            return {}

        token = await self.token.get()
        return {
            &#39;Authorization&#39;: f&#39;Bearer {token}&#39;,
        }

    # TODO: support mutations w version specifiers, return new version (commit)
    @classmethod
    def make_mutation(cls, operation: Operation, key: Key,
                      properties: Dict[str, Any] = None) -&gt; Dict[str, Any]:
        if operation == Operation.DELETE:
            return {operation.value: key.to_repr()}

        return {
            operation.value: {
                &#39;key&#39;: key.to_repr(),
                &#39;properties&#39;: {k: cls.value_kind(v).to_repr()
                               for k, v in properties.items()},
            }
        }

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/allocateIds
    async def allocateIds(self, keys: List[Key],
                          session: Optional[Session] = None,
                          timeout: int = 10) -&gt; List[Key]:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:allocateIds&#39;

        payload = json.dumps({
            &#39;keys&#39;: [k.to_repr() for k in keys],
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.post(url, data=payload, headers=headers, timeout=timeout)
        data = await resp.json()

        return [self.key_kind.from_repr(k) for k in data[&#39;keys&#39;]]

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/beginTransaction
    # TODO: support readwrite vs readonly transaction types
    async def beginTransaction(self, session: Optional[Session] = None,
                               timeout: int = 10) -&gt; str:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:beginTransaction&#39;
        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: &#39;0&#39;,
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.post(url, headers=headers, timeout=timeout)
        data = await resp.json()

        transaction: str = data[&#39;transaction&#39;]
        return transaction

    # TODO: return mutation results
    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/commit
    async def commit(self, mutations: List[Dict[str, Any]],
                     transaction: Optional[str] = None,
                     mode: Mode = Mode.TRANSACTIONAL,
                     session: Optional[Session] = None,
                     timeout: int = 10) -&gt; None:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:commit&#39;

        body = self._make_commit_body(mutations, transaction=transaction,
                                      mode=mode)
        payload = json.dumps(body).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        await s.post(url, data=payload, headers=headers, timeout=timeout)

    # https://cloud.google.com/datastore/docs/reference/admin/rest/v1/projects/export
    async def export(self, output_bucket_prefix: str,
                     kinds: Optional[List[str]] = None,
                     namespaces: Optional[List[str]] = None,
                     labels: Optional[Dict[str, str]] = None,
                     session: Optional[Session] = None,
                     timeout: int = 10) -&gt; DatastoreOperation:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:export&#39;

        payload = json.dumps({
            &#39;entityFilter&#39;: {
                &#39;kinds&#39;: kinds or [],
                &#39;namespaceIds&#39;: namespaces or [],
            },
            &#39;labels&#39;: labels or {},
            &#39;outputUrlPrefix&#39;: f&#39;gs://{output_bucket_prefix}&#39;,
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.post(url, data=payload, headers=headers,
                            timeout=timeout)
        data: dict = await resp.json()

        return self.datastore_operation_kind.from_repr(data)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects.operations/get
    async def get_datastore_operation(self, name: str,
                                      session: Optional[Session] = None,
                                      timeout: int = 10) -&gt; DatastoreOperation:
        url = f&#39;{API_ROOT}/{name}&#39;

        headers = await self.headers()
        headers.update({
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.get(url, headers=headers, timeout=timeout)
        data: dict = await resp.json()

        return self.datastore_operation_kind.from_repr(data)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/lookup
    async def lookup(self, keys: List[Key], transaction: str = None,
                     consistency: Consistency = Consistency.STRONG,
                     session: Optional[Session] = None,
                     timeout: int = 10) -&gt; Dict[str, Union[EntityResult, Key]]:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:lookup&#39;

        if transaction:
            options = {&#39;transaction&#39;: transaction}
        else:
            options = {&#39;readConsistency&#39;: consistency.value}
        payload = json.dumps({
            &#39;keys&#39;: [k.to_repr() for k in keys],
            &#39;readOptions&#39;: options,
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.post(url, data=payload, headers=headers, timeout=timeout)

        data: dict = await resp.json()

        return {
            &#39;found&#39;: [self.entity_result_kind.from_repr(e)
                      for e in data.get(&#39;found&#39;, [])],
            &#39;missing&#39;: [self.entity_result_kind.from_repr(e)
                        for e in data.get(&#39;missing&#39;, [])],
            &#39;deferred&#39;: [self.key_kind.from_repr(k)
                         for k in data.get(&#39;deferred&#39;, [])],
        }

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/reserveIds
    async def reserveIds(self, keys: List[Key], database_id: str = &#39;&#39;,
                         session: Optional[Session] = None,
                         timeout: int = 10) -&gt; None:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:reserveIds&#39;

        payload = json.dumps({
            &#39;databaseId&#39;: database_id,
            &#39;keys&#39;: [k.to_repr() for k in keys],
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        await s.post(url, data=payload, headers=headers, timeout=timeout)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/rollback
    async def rollback(self, transaction: str,
                       session: Optional[Session] = None,
                       timeout: int = 10) -&gt; None:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:rollback&#39;

        payload = json.dumps({
            &#39;transaction&#39;: transaction,
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        await s.post(url, data=payload, headers=headers, timeout=timeout)

    # https://cloud.google.com/datastore/docs/reference/data/rest/v1/projects/runQuery
    async def runQuery(self, query: BaseQuery, transaction: str = None,
                       consistency: Consistency = Consistency.EVENTUAL,
                       session: Optional[Session] = None,
                       timeout: int = 10) -&gt; QueryResultBatch:
        project = await self.project()
        url = f&#39;{API_ROOT}/projects/{project}:runQuery&#39;

        if transaction:
            options = {&#39;transaction&#39;: transaction}
        else:
            options = {&#39;readConsistency&#39;: consistency.value}
        payload = json.dumps({
            &#39;partitionId&#39;: {
                &#39;projectId&#39;: project,
                &#39;namespaceId&#39;: self.namespace,
            },
            query.json_key:  query.to_repr(),
            &#39;readOptions&#39;: options,
        }).encode(&#39;utf-8&#39;)

        headers = await self.headers()
        headers.update({
            &#39;Content-Length&#39;: str(len(payload)),
            &#39;Content-Type&#39;: &#39;application/json&#39;,
        })

        s = AioSession(session) if session else self.session
        resp = await s.post(url, data=payload, headers=headers, timeout=timeout)

        data: dict = await resp.json()
        return self.query_result_batch_kind.from_repr(data[&#39;batch&#39;])

    async def delete(self, key: Key,
                     session: Optional[Session] = None) -&gt; None:
        return await self.operate(Operation.DELETE, key, session=session)

    async def insert(self, key: Key, properties: Dict[str, Any],
                     session: Optional[Session] = None) -&gt; None:
        return await self.operate(Operation.INSERT, key, properties,
                                  session=session)

    async def update(self, key: Key, properties: Dict[str, Any],
                     session: Optional[Session] = None) -&gt; None:
        return await self.operate(Operation.UPDATE, key, properties,
                                  session=session)

    async def upsert(self, key: Key, properties: Dict[str, Any],
                     session: Optional[Session] = None) -&gt; None:
        return await self.operate(Operation.UPSERT, key, properties,
                                  session=session)

    # TODO: accept Entity rather than key/properties?
    async def operate(self, operation: Operation, key: Key,
                      properties: Dict[str, Any] = None,
                      session: Optional[Session] = None) -&gt; None:
        transaction = await self.beginTransaction(session=session)
        mutation = self.make_mutation(operation, key, properties=properties)
        await self.commit([mutation], transaction=transaction, session=session)

    async def close(self):
        await self.session.close()

    async def __aenter__(self) -&gt; &#39;Datastore&#39;:
        return self

    async def __aexit__(self, *args) -&gt; None:
        await self.close()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gcloud.aio.datastore.datastore.Datastore.datastore_operation_kind"><code class="name">var <span class="ident">datastore_operation_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.entity_result_kind"><code class="name">var <span class="ident">entity_result_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.key_kind"><code class="name">var <span class="ident">key_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.query_result_batch_kind"><code class="name">var <span class="ident">query_result_batch_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.value_kind"><code class="name">var <span class="ident">value_kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gcloud.aio.datastore.datastore.Datastore.make_mutation"><code class="name flex">
<span>def <span class="ident">make_mutation</span></span>(<span>operation: <a title="gcloud.aio.datastore.constants.Operation" href="constants.html#gcloud.aio.datastore.constants.Operation">Operation</a>, key: <a title="gcloud.aio.datastore.key.Key" href="key.html#gcloud.aio.datastore.key.Key">Key</a>, properties: Dict[str, Any] = None) -> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def make_mutation(cls, operation: Operation, key: Key,
                  properties: Dict[str, Any] = None) -&gt; Dict[str, Any]:
    if operation == Operation.DELETE:
        return {operation.value: key.to_repr()}

    return {
        operation.value: {
            &#39;key&#39;: key.to_repr(),
            &#39;properties&#39;: {k: cls.value_kind(v).to_repr()
                           for k, v in properties.items()},
        }
    }</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcloud.aio.datastore.datastore.Datastore.allocateIds"><code class="name flex">
<span>async def <span class="ident">allocateIds</span></span>(<span>self, keys: List[<a title="gcloud.aio.datastore.key.Key" href="key.html#gcloud.aio.datastore.key.Key">Key</a>], session: Union[aiohttp.client.ClientSession, NoneType] = None, timeout: int = 10) -> List[<a title="gcloud.aio.datastore.key.Key" href="key.html#gcloud.aio.datastore.key.Key">Key</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def allocateIds(self, keys: List[Key],
                      session: Optional[Session] = None,
                      timeout: int = 10) -&gt; List[Key]:
    project = await self.project()
    url = f&#39;{API_ROOT}/projects/{project}:allocateIds&#39;

    payload = json.dumps({
        &#39;keys&#39;: [k.to_repr() for k in keys],
    }).encode(&#39;utf-8&#39;)

    headers = await self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = AioSession(session) if session else self.session
    resp = await s.post(url, data=payload, headers=headers, timeout=timeout)
    data = await resp.json()

    return [self.key_kind.from_repr(k) for k in data[&#39;keys&#39;]]</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.beginTransaction"><code class="name flex">
<span>async def <span class="ident">beginTransaction</span></span>(<span>self, session: Union[aiohttp.client.ClientSession, NoneType] = None, timeout: int = 10) -> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def beginTransaction(self, session: Optional[Session] = None,
                           timeout: int = 10) -&gt; str:
    project = await self.project()
    url = f&#39;{API_ROOT}/projects/{project}:beginTransaction&#39;
    headers = await self.headers()
    headers.update({
        &#39;Content-Length&#39;: &#39;0&#39;,
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = AioSession(session) if session else self.session
    resp = await s.post(url, headers=headers, timeout=timeout)
    data = await resp.json()

    transaction: str = data[&#39;transaction&#39;]
    return transaction</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self):
    await self.session.close()</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.commit"><code class="name flex">
<span>async def <span class="ident">commit</span></span>(<span>self, mutations: List[Dict[str, Any]], transaction: Union[str, NoneType] = None, mode: <a title="gcloud.aio.datastore.constants.Mode" href="constants.html#gcloud.aio.datastore.constants.Mode">Mode</a> = Mode.TRANSACTIONAL, session: Union[aiohttp.client.ClientSession, NoneType] = None, timeout: int = 10) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def commit(self, mutations: List[Dict[str, Any]],
                 transaction: Optional[str] = None,
                 mode: Mode = Mode.TRANSACTIONAL,
                 session: Optional[Session] = None,
                 timeout: int = 10) -&gt; None:
    project = await self.project()
    url = f&#39;{API_ROOT}/projects/{project}:commit&#39;

    body = self._make_commit_body(mutations, transaction=transaction,
                                  mode=mode)
    payload = json.dumps(body).encode(&#39;utf-8&#39;)

    headers = await self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = AioSession(session) if session else self.session
    await s.post(url, data=payload, headers=headers, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.delete"><code class="name flex">
<span>async def <span class="ident">delete</span></span>(<span>self, key: <a title="gcloud.aio.datastore.key.Key" href="key.html#gcloud.aio.datastore.key.Key">Key</a>, session: Union[aiohttp.client.ClientSession, NoneType] = None) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete(self, key: Key,
                 session: Optional[Session] = None) -&gt; None:
    return await self.operate(Operation.DELETE, key, session=session)</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.export"><code class="name flex">
<span>async def <span class="ident">export</span></span>(<span>self, output_bucket_prefix: str, kinds: Union[List[str], NoneType] = None, namespaces: Union[List[str], NoneType] = None, labels: Union[Dict[str, str], NoneType] = None, session: Union[aiohttp.client.ClientSession, NoneType] = None, timeout: int = 10) -> <a title="gcloud.aio.datastore.datastore_operation.DatastoreOperation" href="datastore_operation.html#gcloud.aio.datastore.datastore_operation.DatastoreOperation">DatastoreOperation</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def export(self, output_bucket_prefix: str,
                 kinds: Optional[List[str]] = None,
                 namespaces: Optional[List[str]] = None,
                 labels: Optional[Dict[str, str]] = None,
                 session: Optional[Session] = None,
                 timeout: int = 10) -&gt; DatastoreOperation:
    project = await self.project()
    url = f&#39;{API_ROOT}/projects/{project}:export&#39;

    payload = json.dumps({
        &#39;entityFilter&#39;: {
            &#39;kinds&#39;: kinds or [],
            &#39;namespaceIds&#39;: namespaces or [],
        },
        &#39;labels&#39;: labels or {},
        &#39;outputUrlPrefix&#39;: f&#39;gs://{output_bucket_prefix}&#39;,
    }).encode(&#39;utf-8&#39;)

    headers = await self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = AioSession(session) if session else self.session
    resp = await s.post(url, data=payload, headers=headers,
                        timeout=timeout)
    data: dict = await resp.json()

    return self.datastore_operation_kind.from_repr(data)</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.get_datastore_operation"><code class="name flex">
<span>async def <span class="ident">get_datastore_operation</span></span>(<span>self, name: str, session: Union[aiohttp.client.ClientSession, NoneType] = None, timeout: int = 10) -> <a title="gcloud.aio.datastore.datastore_operation.DatastoreOperation" href="datastore_operation.html#gcloud.aio.datastore.datastore_operation.DatastoreOperation">DatastoreOperation</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_datastore_operation(self, name: str,
                                  session: Optional[Session] = None,
                                  timeout: int = 10) -&gt; DatastoreOperation:
    url = f&#39;{API_ROOT}/{name}&#39;

    headers = await self.headers()
    headers.update({
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = AioSession(session) if session else self.session
    resp = await s.get(url, headers=headers, timeout=timeout)
    data: dict = await resp.json()

    return self.datastore_operation_kind.from_repr(data)</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.headers"><code class="name flex">
<span>async def <span class="ident">headers</span></span>(<span>self) -> Dict[str, str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def headers(self) -&gt; Dict[str, str]:
    if IS_DEV:
        return {}

    token = await self.token.get()
    return {
        &#39;Authorization&#39;: f&#39;Bearer {token}&#39;,
    }</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.insert"><code class="name flex">
<span>async def <span class="ident">insert</span></span>(<span>self, key: <a title="gcloud.aio.datastore.key.Key" href="key.html#gcloud.aio.datastore.key.Key">Key</a>, properties: Dict[str, Any], session: Union[aiohttp.client.ClientSession, NoneType] = None) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def insert(self, key: Key, properties: Dict[str, Any],
                 session: Optional[Session] = None) -&gt; None:
    return await self.operate(Operation.INSERT, key, properties,
                              session=session)</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.lookup"><code class="name flex">
<span>async def <span class="ident">lookup</span></span>(<span>self, keys: List[<a title="gcloud.aio.datastore.key.Key" href="key.html#gcloud.aio.datastore.key.Key">Key</a>], transaction: str = None, consistency: <a title="gcloud.aio.datastore.constants.Consistency" href="constants.html#gcloud.aio.datastore.constants.Consistency">Consistency</a> = Consistency.STRONG, session: Union[aiohttp.client.ClientSession, NoneType] = None, timeout: int = 10) -> Dict[str, Union[<a title="gcloud.aio.datastore.entity.EntityResult" href="entity.html#gcloud.aio.datastore.entity.EntityResult">EntityResult</a>, <a title="gcloud.aio.datastore.key.Key" href="key.html#gcloud.aio.datastore.key.Key">Key</a>]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def lookup(self, keys: List[Key], transaction: str = None,
                 consistency: Consistency = Consistency.STRONG,
                 session: Optional[Session] = None,
                 timeout: int = 10) -&gt; Dict[str, Union[EntityResult, Key]]:
    project = await self.project()
    url = f&#39;{API_ROOT}/projects/{project}:lookup&#39;

    if transaction:
        options = {&#39;transaction&#39;: transaction}
    else:
        options = {&#39;readConsistency&#39;: consistency.value}
    payload = json.dumps({
        &#39;keys&#39;: [k.to_repr() for k in keys],
        &#39;readOptions&#39;: options,
    }).encode(&#39;utf-8&#39;)

    headers = await self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = AioSession(session) if session else self.session
    resp = await s.post(url, data=payload, headers=headers, timeout=timeout)

    data: dict = await resp.json()

    return {
        &#39;found&#39;: [self.entity_result_kind.from_repr(e)
                  for e in data.get(&#39;found&#39;, [])],
        &#39;missing&#39;: [self.entity_result_kind.from_repr(e)
                    for e in data.get(&#39;missing&#39;, [])],
        &#39;deferred&#39;: [self.key_kind.from_repr(k)
                     for k in data.get(&#39;deferred&#39;, [])],
    }</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.operate"><code class="name flex">
<span>async def <span class="ident">operate</span></span>(<span>self, operation: <a title="gcloud.aio.datastore.constants.Operation" href="constants.html#gcloud.aio.datastore.constants.Operation">Operation</a>, key: <a title="gcloud.aio.datastore.key.Key" href="key.html#gcloud.aio.datastore.key.Key">Key</a>, properties: Dict[str, Any] = None, session: Union[aiohttp.client.ClientSession, NoneType] = None) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def operate(self, operation: Operation, key: Key,
                  properties: Dict[str, Any] = None,
                  session: Optional[Session] = None) -&gt; None:
    transaction = await self.beginTransaction(session=session)
    mutation = self.make_mutation(operation, key, properties=properties)
    await self.commit([mutation], transaction=transaction, session=session)</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.project"><code class="name flex">
<span>async def <span class="ident">project</span></span>(<span>self) -> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def project(self) -&gt; str:
    if self._project:
        return self._project

    self._project = await self.token.get_project()
    if self._project:
        return self._project

    raise Exception(&#39;could not determine project, please set it manually&#39;)</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.reserveIds"><code class="name flex">
<span>async def <span class="ident">reserveIds</span></span>(<span>self, keys: List[<a title="gcloud.aio.datastore.key.Key" href="key.html#gcloud.aio.datastore.key.Key">Key</a>], database_id: str = '', session: Union[aiohttp.client.ClientSession, NoneType] = None, timeout: int = 10) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def reserveIds(self, keys: List[Key], database_id: str = &#39;&#39;,
                     session: Optional[Session] = None,
                     timeout: int = 10) -&gt; None:
    project = await self.project()
    url = f&#39;{API_ROOT}/projects/{project}:reserveIds&#39;

    payload = json.dumps({
        &#39;databaseId&#39;: database_id,
        &#39;keys&#39;: [k.to_repr() for k in keys],
    }).encode(&#39;utf-8&#39;)

    headers = await self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = AioSession(session) if session else self.session
    await s.post(url, data=payload, headers=headers, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.rollback"><code class="name flex">
<span>async def <span class="ident">rollback</span></span>(<span>self, transaction: str, session: Union[aiohttp.client.ClientSession, NoneType] = None, timeout: int = 10) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def rollback(self, transaction: str,
                   session: Optional[Session] = None,
                   timeout: int = 10) -&gt; None:
    project = await self.project()
    url = f&#39;{API_ROOT}/projects/{project}:rollback&#39;

    payload = json.dumps({
        &#39;transaction&#39;: transaction,
    }).encode(&#39;utf-8&#39;)

    headers = await self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = AioSession(session) if session else self.session
    await s.post(url, data=payload, headers=headers, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.runQuery"><code class="name flex">
<span>async def <span class="ident">runQuery</span></span>(<span>self, query: <a title="gcloud.aio.datastore.query.BaseQuery" href="query.html#gcloud.aio.datastore.query.BaseQuery">BaseQuery</a>, transaction: str = None, consistency: <a title="gcloud.aio.datastore.constants.Consistency" href="constants.html#gcloud.aio.datastore.constants.Consistency">Consistency</a> = Consistency.EVENTUAL, session: Union[aiohttp.client.ClientSession, NoneType] = None, timeout: int = 10) -> <a title="gcloud.aio.datastore.query.QueryResultBatch" href="query.html#gcloud.aio.datastore.query.QueryResultBatch">QueryResultBatch</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def runQuery(self, query: BaseQuery, transaction: str = None,
                   consistency: Consistency = Consistency.EVENTUAL,
                   session: Optional[Session] = None,
                   timeout: int = 10) -&gt; QueryResultBatch:
    project = await self.project()
    url = f&#39;{API_ROOT}/projects/{project}:runQuery&#39;

    if transaction:
        options = {&#39;transaction&#39;: transaction}
    else:
        options = {&#39;readConsistency&#39;: consistency.value}
    payload = json.dumps({
        &#39;partitionId&#39;: {
            &#39;projectId&#39;: project,
            &#39;namespaceId&#39;: self.namespace,
        },
        query.json_key:  query.to_repr(),
        &#39;readOptions&#39;: options,
    }).encode(&#39;utf-8&#39;)

    headers = await self.headers()
    headers.update({
        &#39;Content-Length&#39;: str(len(payload)),
        &#39;Content-Type&#39;: &#39;application/json&#39;,
    })

    s = AioSession(session) if session else self.session
    resp = await s.post(url, data=payload, headers=headers, timeout=timeout)

    data: dict = await resp.json()
    return self.query_result_batch_kind.from_repr(data[&#39;batch&#39;])</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.update"><code class="name flex">
<span>async def <span class="ident">update</span></span>(<span>self, key: <a title="gcloud.aio.datastore.key.Key" href="key.html#gcloud.aio.datastore.key.Key">Key</a>, properties: Dict[str, Any], session: Union[aiohttp.client.ClientSession, NoneType] = None) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update(self, key: Key, properties: Dict[str, Any],
                 session: Optional[Session] = None) -&gt; None:
    return await self.operate(Operation.UPDATE, key, properties,
                              session=session)</code></pre>
</details>
</dd>
<dt id="gcloud.aio.datastore.datastore.Datastore.upsert"><code class="name flex">
<span>async def <span class="ident">upsert</span></span>(<span>self, key: <a title="gcloud.aio.datastore.key.Key" href="key.html#gcloud.aio.datastore.key.Key">Key</a>, properties: Dict[str, Any], session: Union[aiohttp.client.ClientSession, NoneType] = None) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def upsert(self, key: Key, properties: Dict[str, Any],
                 session: Optional[Session] = None) -&gt; None:
    return await self.operate(Operation.UPSERT, key, properties,
                              session=session)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcloud.aio.datastore" href="index.html">gcloud.aio.datastore</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcloud.aio.datastore.datastore.Datastore" href="#gcloud.aio.datastore.datastore.Datastore">Datastore</a></code></h4>
<ul class="">
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.allocateIds" href="#gcloud.aio.datastore.datastore.Datastore.allocateIds">allocateIds</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.beginTransaction" href="#gcloud.aio.datastore.datastore.Datastore.beginTransaction">beginTransaction</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.close" href="#gcloud.aio.datastore.datastore.Datastore.close">close</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.commit" href="#gcloud.aio.datastore.datastore.Datastore.commit">commit</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.datastore_operation_kind" href="#gcloud.aio.datastore.datastore.Datastore.datastore_operation_kind">datastore_operation_kind</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.delete" href="#gcloud.aio.datastore.datastore.Datastore.delete">delete</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.entity_result_kind" href="#gcloud.aio.datastore.datastore.Datastore.entity_result_kind">entity_result_kind</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.export" href="#gcloud.aio.datastore.datastore.Datastore.export">export</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.get_datastore_operation" href="#gcloud.aio.datastore.datastore.Datastore.get_datastore_operation">get_datastore_operation</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.headers" href="#gcloud.aio.datastore.datastore.Datastore.headers">headers</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.insert" href="#gcloud.aio.datastore.datastore.Datastore.insert">insert</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.key_kind" href="#gcloud.aio.datastore.datastore.Datastore.key_kind">key_kind</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.lookup" href="#gcloud.aio.datastore.datastore.Datastore.lookup">lookup</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.make_mutation" href="#gcloud.aio.datastore.datastore.Datastore.make_mutation">make_mutation</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.operate" href="#gcloud.aio.datastore.datastore.Datastore.operate">operate</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.project" href="#gcloud.aio.datastore.datastore.Datastore.project">project</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.query_result_batch_kind" href="#gcloud.aio.datastore.datastore.Datastore.query_result_batch_kind">query_result_batch_kind</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.reserveIds" href="#gcloud.aio.datastore.datastore.Datastore.reserveIds">reserveIds</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.rollback" href="#gcloud.aio.datastore.datastore.Datastore.rollback">rollback</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.runQuery" href="#gcloud.aio.datastore.datastore.Datastore.runQuery">runQuery</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.update" href="#gcloud.aio.datastore.datastore.Datastore.update">update</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.upsert" href="#gcloud.aio.datastore.datastore.Datastore.upsert">upsert</a></code></li>
<li><code><a title="gcloud.aio.datastore.datastore.Datastore.value_kind" href="#gcloud.aio.datastore.datastore.Datastore.value_kind">value_kind</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>